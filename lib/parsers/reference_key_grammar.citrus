require "common_grammar"

grammar Parsers::ReferenceKeyGrammar
  include Parsers::CommonGrammar

  rule reference_key
    ( reference_key_with_et_al
    | reference_key_with_two_authors_plus_et_al
    | reference_key_without_et_al
    | reference_key_without_year
    )
  end

  rule reference_key_with_et_al
    (name_word ', <i>et al.</i>' s year? year_ordinal?) {
      value = {}
      value[:author_last_names] = [name_word.value.to_s]
      value[:nester_last_names] = nil
      value[:year] = year
      value[:year_ordinal] = year_ordinal
      value
    }
  end

  rule reference_key_with_two_authors_plus_et_al
    (name_word ','? ' ' name_word s "<i>et al.</i>" s year? year_ordinal?) {
      value = {}
      value = {author_last_names: captures[:name_word].map(&:to_s)}
      value[:nester_last_names] = nil
      value[:year] = year
      value[:year_ordinal] = year_ordinal
      value
    }
  end

  rule reference_key_without_et_al
    (author_names ','? 'in citation'? s year? year_ordinal?) {
      value = {}
      value[:author_last_names] = author_names.value[:names]
      value[:nester_last_names] = nil
      value[:year] = year
      value[:year_ordinal] = year_ordinal
      value
    }
  end

  rule reference_key_without_year
    # Trailing 's' rule invocation appears to be necessary because
    # of a bug in Citrus
    (name_word s) {
      value = {}
      value[:author_last_names] = [name_word.value]
      value[:nester_last_names] = nil
      value[:year] = nil
      value[:year_ordinal] = nil
      value
    }
  end

  rule year_ordinal
    /[a-z]/
  end

  rule author_names
    (author (s author_separator s author)* suffix? s) {
      value = {:names => captures[:author].map(&:to_s)}
      value[:suffix] = suffix.to_s if suffix
      value
    }
  end

  rule author
    !suffix name_phrase (',' initial+)? author_suffix?
  end

  rule author_suffix
    (', Jr' '.'?) | (', Sr' '.'?) | ', III' | ', II'
  end

  rule author_separator
    ';' | ',' | '&'
  end

  rule initial
      (s ('dos' | 'da' | 'de' | 'di' | 'del' | 'do'))
    | (s name_char '.'? '-' name_char '.')
    | (s abbreviated_first_name)
    | (s name_char_without_period_but_before_semicolon)
  end

  rule abbreviated_first_name
    /[[:upper:]][[:lower:]]*\./
  end

  rule suffix
    et_al role | et_al | role
  end

  rule role
    s '(' [^)]+ ')'
  end

  rule et_al
    ', '? s 'et al.'
  end

  rule name_phrase
    name_word (s name_word)*
  end

  rule name_word
    name_char+ '.'?
  end

  rule name_char
    /[^[:punct:][:digit:]\s]/ | /[\-\']/
  end

  rule name_char_without_period_but_before_semicolon
    /[\-\'\w](?=;)/
  end
end
