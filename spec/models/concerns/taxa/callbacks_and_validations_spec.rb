require 'spec_helper'

describe Taxa::CallbacksAndValidations do
  include RefactorTaxonFactoriesHelpers

  describe "#build_default_taxon_state and #set_taxon_state_to_waiting" do
    context "when creating a taxon" do
      let(:taxon) { build_minimal_family }

      it "creates a taxon_state" do
        expect(taxon.taxon_state).to be nil
        taxon.save
        expect(taxon.taxon_state).not_to be nil
      end

      it "sets the review_status to 'waiting'" do
        taxon.save
        expect(taxon.waiting?).to be true
      end
    end

    context "when updating" do
      let(:taxon) { an_old_taxon }

      context "when it `save_initiator`" do
        it "sets the review_status to 'waiting'" do
          taxon.save_initiator = true
          taxon.save
          expect(taxon.waiting?).to be true
        end

        it "doesn't cascade" do
          family = create :family, :old
          subfamily = create :subfamily, :old, family: family

          expect(family.waiting?).to be false
          expect(subfamily.waiting?).to be false

          family.save_initiator = true
          family.save

          expect(family.waiting?).to be true
          expect(subfamily.waiting?).to be false
        end
      end

      context "when it not `save_initiator`" do
        it "doesn't change the review state" do
          expect { taxon.save }.to_not change { taxon.old? }
        end
      end
    end
  end

  describe "#remove_auto_generated" do
    include MarkAsAutogeneratedHelpers

    context "when a generated taxon" do
      it "removes 'auto_generated' flags from things" do
        # Setup.
        taxon = create :family
        another_taxon = create :family
        synonym = create :synonym, senior_synonym: taxon, junior_synonym: another_taxon

        actors = [taxon, taxon.name, synonym]

        mark_as_auto_generated actors
        actors.each &:reload

        # Act and test.
        taxon.save_initiator = true
        taxon.save
        actors.each &:reload

        actors.each { |object| expect(object).not_to be_auto_generated }
      end

      it "doesn't cascade" do
        # Setup.
        family = create :family
        subfamily = create :subfamily, family: family

        actors = [family, subfamily, family.name, subfamily.name]
        mark_as_auto_generated actors
        actors.each &:reload

        # Act and test.
        family.save_initiator = true
        family.save
        actors.each &:reload

        expect(family).not_to be_auto_generated
        expect(family.name).not_to be_auto_generated
        expect(subfamily).to be_auto_generated
        expect(subfamily.name).to be_auto_generated
      end
    end
  end

  # TODO improve "expect_any_instance_of" etc.
  describe "#save_children" do
    let!(:species) { create :species }
    let!(:genus) { Taxon.find species.genus.id }
    let!(:tribe) { Taxon.find genus.tribe.id }
    let!(:subfamily) { Taxon.find species.subfamily.id }

    context "when taxon is not the `save_initiator`" do
      it "doesn't save the children" do
        # The `save_initiator` should be saved.
        expect(subfamily).to receive(:save).and_call_original
        expect_any_instance_of(Subfamily).not_to receive(:save_children).and_call_original

        # But not its children.
        [Tribe, Genus, Species].each do |klass|
          expect_any_instance_of(klass).not_to receive(:save_children).and_call_original
          expect_any_instance_of(klass).not_to receive(:save).and_call_original
        end

        subfamily.save
      end
    end

    context "when taxon is the `save_initiator`" do
      it "saves the children" do
        # All children should be saved, and their children too.
        [Subfamily, Tribe, Genus, Species].each do |klass|
          expect_any_instance_of(klass).to receive(:save_children).and_call_original
          expect_any_instance_of(klass).to receive(:save).and_call_original
        end

        # But not the family.
        expect_any_instance_of(Family).not_to receive(:save_children).and_call_original

        subfamily.save_initiator = true
        subfamily.save
      end

      it "doesn't save unrelated taxa" do
        another_subfamily = minimal_subfamily

        expect(another_subfamily).to receive(:save).and_call_original
        expect(subfamily).not_to receive(:save).and_call_original

        [Tribe, Genus, Species].each do |klass|
          expect_any_instance_of(klass).not_to receive(:save_children).and_call_original
          expect_any_instance_of(klass).not_to receive(:save).and_call_original
        end

        another_subfamily.save_initiator = true
        another_subfamily.save
      end

      it "never recursively saves children of families" do
        family = minimal_family

        family.save_initiator = true
        expect(family.save_children).to be nil

        # Confirm test isn't borked.
        subfamily.save_initiator = true
        expect(subfamily.save_children).not_to be nil
      end
    end
  end

  describe "#set_name_caches" do
    # TODO
  end

  describe "#delete_synonyms" do
    let(:senior) { create :family }
    let(:junior) { create :family, :synonym }

    before { create :synonym, junior_synonym: junior, senior_synonym: senior }

    it "*confirm test setup*" do
      expect(junior.status).to eq Status::SYNONYM
      expect(senior.junior_synonyms.count).to eq 1
      expect(junior.senior_synonyms.count).to eq 1
    end

    describe "saving a taxon" do
      context "with the status 'synonym'" do
        context "when status was not changed" do
          it "doesn't destroy any synonyms" do
            junior.fossil = true

            expect { junior.save! }.not_to change { Synonym.count }
            expect(senior.junior_synonyms.count).to eq 1
            expect(junior.senior_synonyms.count).to eq 1
          end
        end

        context "when status was changed from 'synonym'" do
          it "destroys all synonyms where it's the junior" do
            junior.status = Status::VALID

            expect { junior.save! }.to change { Synonym.count }.by -1
            expect(senior.junior_synonyms.count).to eq 0
            expect(junior.senior_synonyms.count).to eq 0
          end
        end
      end

      context "when taxon doesn't have the status 'synonym'" do
        context "when status was changed" do
          it "doesn't destroy any synonyms" do
            senior.status = Status::HOMONYM

            expect { senior.save! }.not_to change { Synonym.count }
            expect(senior.junior_synonyms.count).to eq 1
            expect(junior.senior_synonyms.count).to eq 1
          end
        end
      end
    end
  end

  describe "#current_valid_taxon_validation" do
    context "when a valid taxon has a `#current_valid_taxon`" do
      let(:taxon) { build :family, current_valid_taxon: create(:family) }

      specify do
        taxon.valid?
        expect(taxon.errors.messages).to include(current_valid_name: ["can't be set for valid taxa"])
      end
    end

    context "when an  taxon has a `#current_valid_taxon`" do
      let(:taxon) { build :family, :unavailable, current_valid_taxon: create(:family) }

      specify do
        taxon.valid?
        expect(taxon.errors.messages).to include(current_valid_name: ["can't be set for unavailable taxa"])
      end
    end
  end
end
